# API Endpoint Implementation Plan: GET /api/plans/{id} (v2 Schema)

**Updated**: 2025-10-20
**Schema Version**: v2 (Multi-portion meal support with portions_to_cook)

---

## 1. PrzeglƒÖd punktu ko≈Ñcowego

**Cel**: Pobraƒá kompletne szczeg√≥≈Çy planu ≈ºywieniowego dla konkretnego u≈ºytkownika, w tym wszystkie dni, posi≈Çki, przepisy i parametry multi-portion meal support (v2).

**Kontekst biznesowy**:
- U≈ºytkownik chce wy≈õwietliƒá wcze≈õniej wygenerowany plan z pe≈Çnymi szczeg√≥≈Çami
- Obejmuje zagnie≈ºd≈ºone struktury: dni ‚Üí posi≈Çki ‚Üí przepisy
- **v2 ZMIANA**: Zwraca `portions_to_cook` (ile porcji gotowaƒá) i rozr√≥≈ºnia dzie≈Ñ gotowania vs resztki
- Wymagana autoryzacja na poziomie u≈ºytkownika (ka≈ºdy widzi tylko swoje plany)

**Funkcjonalno≈õƒá**:
- Pobiera plan wraz ze wszystkimi powiƒÖzanymi danymi
- Zwraca celki kalorii na poszczeg√≥lne sloty posi≈Çk√≥w
- Zwraca szczeg√≥≈Çy przepis√≥w dla ka≈ºdego posi≈Çku
- **v2 NEW**: Zwraca `portions_to_cook` dla ka≈ºdego posi≈Çku
- **v2 NEW**: Pokazuje multi-portion grupy (via `multi_portion_group_id`)
- Obs≈Çuguje skalowanie w pionie (zagnie≈ºd≈ºone zasoby)

---

## 2. Szczeg√≥≈Çy ≈ºƒÖdania

### Metoda HTTP i Route
- **Metoda**: GET
- **Route**: `/api/plans/{id}`
- **Handler**: `src/pages/api/plans/[id].ts`

### Parametry
- **URL Parameter (wymagany)**:
    - `id` (string ‚Üí number): ID planu do pobrania
    - Typ: BIGINT (w bazie danych)
    - Walidacja: musi byƒá dodatniƒÖ liczbƒÖ ca≈ÇkowitƒÖ

- **Parametry opcjonalne**: Brak

- **Query String**: Brak

### Request Headers
- `Authorization`: Bearer token (obs≈Çugiwany przez middleware)
- `Content-Type`: Nie wymagany (GET request)

### Request Body
Brak (GET request)

---

## 3. Wykorzystywane typy

### Response DTOs (v2 Updated)

```typescript
// Main response - wrapped format
{
  "data": PlanDetailsResponse
}

// PlanDetailsResponse (z types.ts)
type PlanDetailsResponse = PlanDTO & {
  days: PlanDayResponse[]
}

// PlanDTO - podstawowe pola planu
type PlanDTO = {
  id: number
  user_id: string
  state: Enums<'plan_state'>  // 'active' | 'archived' | 'draft'
  start_date: string          // ISO date
  end_date: string            // ISO date
  created_at: string          // ISO timestamp
  updated_at: string          // ISO timestamp
}

// PlanDayResponse - dzie≈Ñ z posi≈Çkami i celami
type PlanDayResponse = {
  id: number
  plan_id: number
  date: string                // ISO date
  meals: MealResponse[]
  slot_targets: SlotTargetResponse[]
}

// üîÑ UPDATED for v2 semantics
type MealResponse = {
  id: number
  slot: Enums<'meal_slot'>           // 'breakfast' | 'lunch' | 'dinner' | 'snack'
  status: Enums<'meal_status'>       // 'planned' | 'cooked' | 'eaten' | 'skipped'
  calories_planned: number
  portion_multiplier: number         // üîÑ Now: actual portions to eat (e.g., 2.4, 3.0)
  portions_to_cook: number | null    // üÜï NEW: Set for day 1 (cooking), NULL for day 2 (leftovers)
  multi_portion_group_id: string | null  // Groups consecutive days for leftovers
  is_leftover: boolean               // true = day 2 (leftovers), false = day 1 (cooking)
  recipe: RecipeInMealResponse
}

// RecipeInMealResponse - subset danych przepisu w posi≈Çku
type RecipeInMealResponse = {
  id: number
  name: string
  image_url: string | null
  time_minutes: number | null
  source_url: string | null
  available_slots: Enums<'meal_slot'>[]
}

// SlotTargetResponse - cel kalorii dla slotu
type SlotTargetResponse = {
  slot: Enums<'meal_slot'>
  calories_target: number
}
```

### Input Validation Schemas

```typescript
// Zod schema dla walidacji ID (w src/lib/schemas/plan.ts)
export const getPlanIdSchema = z.object({
  id: z.string().transform(Number).pipe(
    z.number().int().positive('Plan ID must be a positive integer')
  )
})

type GetPlanIdInput = z.infer<typeof getPlanIdSchema>
```

---

## 4. Szczeg√≥≈Çy odpowiedzi

### Struktura odpowiedzi (200 OK) ‚Äî v2 Updated

```json
{
  "data": {
    "id": 1,
    "user_id": "550e8400-e29b-41d4-a716-446655440000",
    "state": "active",
    "start_date": "2024-01-15",
    "end_date": "2024-01-21",
    "created_at": "2024-01-15T10:00:00Z",
    "updated_at": "2024-01-15T10:00:00Z",
    "days": [
      {
        "id": 1,
        "plan_id": 1,
        "date": "2024-01-15",
        "meals": [
          {
            "id": 101,
            "slot": "breakfast",
            "status": "planned",
            "calories_planned": 400,
            "portion_multiplier": 1.0,
            "portions_to_cook": 4,
            "multi_portion_group_id": null,
            "is_leftover": false,
            "recipe": {
              "id": 42,
              "name": "Healthy Breakfast Bowl",
              "image_url": "https://example.com/image.jpg",
              "time_minutes": 15,
              "source_url": "https://cookido.com/recipe/123",
              "available_slots": ["breakfast", "lunch"]
            }
          },
          {
            "id": 102,
            "slot": "lunch",
            "status": "planned",
            "calories_planned": 600,
            "portion_multiplier": 2.4,
            "portions_to_cook": 6,
            "multi_portion_group_id": "550e8400-e29b-41d4-a716-446655440001",
            "is_leftover": false,
            "recipe": {
              "id": 200,
              "name": "Gulasz (6-porcyjny)",
              "image_url": "https://example.com/gulasz.jpg",
              "time_minutes": 45,
              "source_url": "https://cookido.com/recipe/200",
              "available_slots": ["lunch", "dinner"]
            }
          },
          {
            "id": 103,
            "slot": "dinner",
            "status": "planned",
            "calories_planned": 600,
            "portion_multiplier": 2.4,
            "portions_to_cook": 6,
            "multi_portion_group_id": "550e8400-e29b-41d4-a716-446655440002",
            "is_leftover": false,
            "recipe": {
              "id": 201,
              "name": "Pizza (6-porcyjne)",
              "image_url": "https://example.com/pizza.jpg",
              "time_minutes": 30,
              "source_url": "https://cookido.com/recipe/201",
              "available_slots": ["lunch", "dinner"]
            }
          },
          {
            "id": 104,
            "slot": "snack",
            "status": "planned",
            "calories_planned": 400,
            "portion_multiplier": 1.0,
            "portions_to_cook": 1,
            "multi_portion_group_id": null,
            "is_leftover": false,
            "recipe": {
              "id": 333,
              "name": "Jogurt",
              "image_url": "https://example.com/jogurt.jpg",
              "time_minutes": 0,
              "source_url": "https://cookido.com/recipe/333",
              "available_slots": ["snack"]
            }
          }
        ],
        "slot_targets": [
          {
            "slot": "breakfast",
            "calories_target": 400
          },
          {
            "slot": "lunch",
            "calories_target": 600
          },
          {
            "slot": "dinner",
            "calories_target": 600
          },
          {
            "slot": "snack",
            "calories_target": 400
          }
        ]
      },
      {
        "id": 2,
        "plan_id": 1,
        "date": "2024-01-16",
        "meals": [
          {
            "id": 105,
            "slot": "breakfast",
            "status": "planned",
            "calories_planned": 400,
            "portion_multiplier": 1.0,
            "portions_to_cook": 3,
            "multi_portion_group_id": null,
            "is_leftover": false,
            "recipe": {
              "id": 43,
              "name": "Omelet",
              "image_url": "https://example.com/omelet.jpg",
              "time_minutes": 10,
              "source_url": "https://cookido.com/recipe/43",
              "available_slots": ["breakfast", "lunch"]
            }
          },
          {
            "id": 106,
            "slot": "lunch",
            "status": "planned",
            "calories_planned": 600,
            "portion_multiplier": 2.4,
            "portions_to_cook": null,
            "multi_portion_group_id": "550e8400-e29b-41d4-a716-446655440001",
            "is_leftover": true,
            "recipe": {
              "id": 200,
              "name": "Gulasz (6-porcyjny)",
              "image_url": "https://example.com/gulasz.jpg",
              "time_minutes": 45,
              "source_url": "https://cookido.com/recipe/200",
              "available_slots": ["lunch", "dinner"]
            }
          },
          {
            "id": 107,
            "slot": "dinner",
            "status": "planned",
            "calories_planned": 600,
            "portion_multiplier": 2.4,
            "portions_to_cook": null,
            "multi_portion_group_id": "550e8400-e29b-41d4-a716-446655440002",
            "is_leftover": true,
            "recipe": {
              "id": 201,
              "name": "Pizza (6-porcyjne)",
              "image_url": "https://example.com/pizza.jpg",
              "time_minutes": 30,
              "source_url": "https://cookido.com/recipe/201",
              "available_slots": ["lunch", "dinner"]
            }
          },
          {
            "id": 108,
            "slot": "snack",
            "status": "planned",
            "calories_planned": 400,
            "portion_multiplier": 1.0,
            "portions_to_cook": 1,
            "multi_portion_group_id": null,
            "is_leftover": false,
            "recipe": {
              "id": 334,
              "name": "Banan",
              "image_url": "https://example.com/banan.jpg",
              "time_minutes": 0,
              "source_url": "https://cookido.com/recipe/334",
              "available_slots": ["snack"]
            }
          }
        ],
        "slot_targets": [
          {
            "slot": "breakfast",
            "calories_target": 400
          },
          {
            "slot": "lunch",
            "calories_target": 600
          },
          {
            "slot": "dinner",
            "calories_target": 600
          },
          {
            "slot": "snack",
            "calories_target": 400
          }
        ]
      }
    ]
  }
}
```

**Wyja≈õnienie v2 semantyki** w przyk≈Çadzie:
- **Day 1 (2024-01-15) Lunch** (ID 102):
    - `portion_multiplier: 2.4` ‚Üí Zjedz 2.4 porcje
    - `portions_to_cook: 6` ‚Üí Przepis ma 6 porcji, gotuj ca≈Ço≈õƒá
    - `is_leftover: false` ‚Üí To dzie≈Ñ gotowania
    - `multi_portion_group_id: ...` ‚Üí Grupa multi-portion

- **Day 2 (2024-01-16) Lunch** (ID 106):
    - `portion_multiplier: 2.4` ‚Üí **IDENTICAL** as Day 1
    - `portions_to_cook: null` ‚Üí Nie gotuj! Resztki
    - `is_leftover: true` ‚Üí To dzie≈Ñ restek
    - `multi_portion_group_id: ...` ‚Üí **SAME group** as Day 1

### Kody statusu i odpowiedzi b≈Çƒôd√≥w

| Kod | Scenariusz | Odpowied≈∫ |
|-----|-----------|----------|
| **200** | Plan znaleziony i autoryzowany | Pe≈Çne dane planu z zagnie≈ºd≈ºonymi danymi (v2 updated) |
| **400** | Nieprawid≈Çowy format ID | `{"error": "Invalid plan ID"}` |
| **401** | Brak autoryzacji (brak tokenu) | `{"error": "Unauthorized"}` |
| **403** | Plan nale≈ºy do innego u≈ºytkownika | `{"error": "Access denied"}` |
| **404** | Plan nie istnieje | `{"error": "Plan not found"}` |
| **500** | B≈ÇƒÖd bazy danych | `{"error": "Internal server error"}` |

---

## 5. Przep≈Çyw danych (v2 Updated)

### Architektura zapyta≈Ñ

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ GET /api/plans/{id}                     ‚îÇ
‚îÇ Headers: Authorization: Bearer <token>  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
               ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ Middleware      ‚îÇ
        ‚îÇ Ekstraktuj:     ‚îÇ
        ‚îÇ - user_id       ‚îÇ
        ‚îÇ - session       ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ Walidacja ID (Zod)   ‚îÇ
        ‚îÇ Parsuj: string ‚Üí int ‚îÇ
        ‚îÇ Sprawd≈∫: > 0         ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ plans.service                 ‚îÇ
        ‚îÇ .getPlanDetailsWithMeals()    ‚îÇ
        ‚îÇ (v2: includes portions_to_cook)
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ           ‚îÇ           ‚îÇ
     ‚ñº           ‚ñº           ‚ñº
  Query 1     Query 2     Query 3
  plans       plan_days   (dla ka≈ºdego dnia)
  WHERE       WHERE        - plan_day_slot_targets
    id        plan_id      - plan_meals (JOIN recipes)
    user_id   (autoryzacja)
                           üÜï including portions_to_cook
     ‚îÇ           ‚îÇ           ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ Transformuj do DTO   ‚îÇ
        ‚îÇ (v2: map portions_to_cook)
        ‚îÇ PlanDetailsResponse  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ
                 ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ Return 200 OK        ‚îÇ
        ‚îÇ { data: ... }        ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Szczeg√≥≈Çowe kroki dostƒôpu do danych

**Krok 1: Pobranie g≈Ç√≥wnego planu**
```sql
SELECT id, user_id, state, start_date, end_date, created_at, updated_at
FROM plans
WHERE id = $1 AND user_id = $2
```
- **$1**: plan ID (z URL)
- **$2**: authenticated user ID (z kontekstu)
- **Cel autoryzacji**: Upewnij siƒô, ≈ºe plan nale≈ºy do bie≈ºƒÖcego u≈ºytkownika

**Krok 2: Pobranie dni planu**
```sql
SELECT id, plan_id, date, created_at, updated_at
FROM plan_days
WHERE plan_id = $1
ORDER BY date ASC
```
- **$1**: plan ID
- **Zakres**: Wszystkie dni od start_date do end_date

**Krok 3: Dla ka≈ºdego dnia - Pobranie cel√≥w slot√≥w**
```sql
SELECT slot, calories_target
FROM plan_day_slot_targets
WHERE plan_day_id = $1
```
- **$1**: plan_day ID
- **Znormalizuj**: Slot jako enum, calories_target jako liczba

**Krok 4: Dla ka≈ºdego dnia - Pobranie posi≈Çk√≥w z przepisami (v2 Updated)**
```sql
SELECT
  pm.id, pm.slot, pm.status, pm.calories_planned,
  pm.portion_multiplier, pm.portions_to_cook,    -- üÜï NEW
  pm.multi_portion_group_id, pm.is_leftover,
  r.id as recipe_id, r.name, r.image_url, r.time_minutes,
  r.source_url, r.available_slots
FROM plan_meals pm
JOIN recipes r ON pm.recipe_id = r.id
WHERE pm.plan_day_id = $1
ORDER BY pm.slot ASC
```
- **$1**: plan_day ID
- **Slot order**: breakfast ‚Üí lunch ‚Üí dinner ‚Üí snack
- **üÜï KEY CHANGE**: Teraz pobieramy `pm.portions_to_cook` z bazy

### Transformacja danych (v2 Updated)

Po pobraniu surowych danych z bazy:

1. Zgrupuj posi≈Çki po dniach
2. Mapuj ka≈ºdy posi≈Çek na `MealResponse` z:
    - `portion_multiplier` (liczba porcji do zjedzenia)
    - **`portions_to_cook`** (ile porcji gotowaƒá ‚Äî recipe.portions lub NULL)
    - `is_leftover` (czy to resztki)
    - `multi_portion_group_id` (ID grupy dla multi-portion)
    - zagnie≈ºd≈ºonym `RecipeInMealResponse`
3. Mapuj cele na `SlotTargetResponse`
4. Utw√≥rz strukturƒô `PlanDetailsResponse`
5. Zwr√≥ƒá w formacie: `{ data: PlanDetailsResponse }`

**Pseudo-kod transformacji**:
```typescript
const mealResponse: MealResponse = {
  id: rawMeal.id,
  slot: rawMeal.slot,
  status: rawMeal.status,
  calories_planned: rawMeal.calories_planned,
  portion_multiplier: rawMeal.portion_multiplier,
  portions_to_cook: rawMeal.portions_to_cook,  // üÜï NEW: map from DB
  multi_portion_group_id: rawMeal.multi_portion_group_id,
  is_leftover: rawMeal.is_leftover,
  recipe: mapRecipe(rawMeal)
}
```

---

## 6. Wzglƒôdy bezpiecze≈Ñstwa

### Uwierzytelnianie
- **Wymagane**: Middleware `/src/middleware/index.ts` musi sprawdziƒá wa≈ºno≈õƒá tokenu Supabase
- **Token Source**: Header `Authorization: Bearer <token>`
- **Supabase**: Automatycznie mapuje token na `user_id` w `context.locals`
- **Fallback**: Je≈õli brak tokenu, middleware powinien zwr√≥ciƒá 401 Unauthorized

### Autoryzacja (RLS - Row Level Security)
- **Zasada**: Ka≈ºdy u≈ºytkownik mo≈ºe widzieƒá tylko swoje plany
- **Implementacja na poziomie aplikacji**:
    - W `plans.service.getPlanDetailsWithMeals()` sprawdziƒá: `plan.user_id === context.user_id`
    - Zwr√≥ƒá 403 Forbidden, je≈õli nie pasuje
- **Implementacja na poziomie bazy (RLS)**:
    - Tabela `plans` powinna mieƒá politykƒô: `user_id = auth.uid()`
    - Dzia≈Çamy ponad RLS, ale dodatkowy check zapewnia defense-in-depth

### Walidacja danych wej≈õciowych
- **URL Parameter**: Zod schema - konwersja string ‚Üí number, sprawdzenie dodatno≈õci
- **Typ**: Musi byƒá integer (bez warto≈õci zmiennoprzecinkowych)
- **Zakres**: Brak g√≥rnego limitu (relies on BIGINT limit)

### Bezpiecze≈Ñstwo tre≈õci odpowiedzi
- **DTO Structure**: `RecipeInMealResponse` zawiera tylko publiczne pola przepisu
- **Unikaj**: Wewnƒôtrznych ID u≈ºytkownik√≥w, hash has≈Ça, token API
- **PII**: Brak PII w odpowiedzi (plan_meals zawiera tylko metryki publiczne)
- **v2 Safety**: `portions_to_cook` to publiczna metrika, bezpieczna do ujawnienia

### Ochrona przed atakami

| Atak | Mitygacja |
|------|-----------|
| **SQL Injection** | Supabase SDK u≈ºywa prepared statements; brak raw SQL |
| **Unauthorized Access** | RLS + app-level `user_id` check |
| **Parameter Tampering** | Zod walidacja ID; parsing bezpieczny |
| **DoS (large response)** | Limit liczby dni (np. max 365 dni na plan) - optional paging w przysz≈Ço≈õci |
| **Information Disclosure** | DTO structure controls output fields |

---

## 7. Obs≈Çuga b≈Çƒôd√≥w

### Strategie obs≈Çugi b≈Çƒôd√≥w (v2)

#### Early Return Pattern
Obs≈Çuguj b≈Çƒôdy na poczƒÖtku funkcji, u≈ºywajƒÖc guard clauses:

```typescript
export async function GET({ params, locals }: APIContext) {
  // Sprawdzenie autoryzacji (Early Return)
  if (!locals.user) {
    return new Response(
      JSON.stringify({ error: "Unauthorized" }),
      { status: 401, headers: { 'Content-Type': 'application/json' } }
    )
  }

  // Walidacja parametr√≥w (Early Return)
  const { id: planIdRaw } = params
  if (!planIdRaw || isNaN(Number(planIdRaw))) {
    return new Response(
      JSON.stringify({ error: "Invalid plan ID" }),
      { status: 400, headers: { 'Content-Type': 'application/json' } }
    )
  }
  const planId = Number(planIdRaw)

  // Reszta logiki...
}
```

### Mapa b≈Çƒôd√≥w i odpowiadajƒÖce im odpowiedzi

| B≈ÇƒÖd | Kod | Przyczyna | Odpowied≈∫ |
|------|-----|----------|----------|
| **AuthenticationError** | 401 | Brak tokenu lub token niewa≈ºny | `{"error": "Unauthorized"}` |
| **AuthorizationError** | 403 | Plan nale≈ºy do innego u≈ºytkownika | `{"error": "Access denied"}` |
| **ValidationError** | 400 | ID nie jest liczbƒÖ | `{"error": "Invalid plan ID"}` |
| **NotFoundError** | 404 | Plan nie istnieje | `{"error": "Plan not found"}` |
| **DatabaseError** | 500 | B≈ÇƒÖd po≈ÇƒÖczenia/query | `{"error": "Internal server error"}` |
| **UnexpectedError** | 500 | Nienoczekiwany wyjƒÖtek | `{"error": "Internal server error"}` |

### Logowanie b≈Çƒôd√≥w
- **Gdzie**: Centralny `src/lib/errors.ts` lub serwis
- **Co logowaƒá**:
    - Typ b≈Çƒôdu (AuthorizationError, DatabaseError, etc.)
    - User ID (dla kontekstu)
    - Plan ID
    - Error message i stack trace (dla 5xx)
- **Poziom**:
    - `warn`: 4xx b≈Çƒôdy (validation, auth)
    - `error`: 5xx b≈Çƒôdy (database, unexpected)
- **Nie logowaƒá**: Tokeny, has≈Ça, wra≈ºliwe PII

### Obs≈Çuga scenariuszy edge case (v2 Updated)

| Scenariusz | Obs≈Çuga |
|-----------|---------|
| Plan ma 0 dni | Zwr√≥ƒá pusty array `days: []` |
| Dzie≈Ñ ma 0 posi≈Çk√≥w | Zwr√≥ƒá pusty array `meals: []` |
| Dzie≈Ñ ma 0 cel√≥w slot√≥w | Zwr√≥ƒá pusty array `slot_targets: []` |
| `portions_to_cook` = NULL | Normalne ‚Äî resztki (is_leftover=TRUE) |
| Przepis dla posi≈Çku usuniƒôty (orphaned meal) | Zwr√≥ƒá 500 (data integrity error) - should not happen with FK |
| Multi-portion grupa z r√≥≈ºnymi multipliers | Zwr√≥ƒá 500 (constraint violation) ‚Äî wyzwalacz powinien to zabezpieczyƒá |
| Nieoczekiwana struktura danych | Zwr√≥ƒá 500 i zaloguj (warning sign) |

---

## 8. Rozwa≈ºania dotyczƒÖce wydajno≈õci

### Potencjalne wƒÖskie gard≈Ça

#### 1. N+1 Query Problem
**WƒÖskie gard≈Ço**: Pobranie g≈Ç√≥wnego planu, potem dla ka≈ºdego dnia osobne query na posi≈Çki
**RozwiƒÖzanie**:
- Jedno JOIN zapytanie: `plan_meals JOIN recipes` dla wszystkich dni naraz
- Grupowanie w aplikacji (JavaScript) zamiast wielu queries

```typescript
// Efektywnie: Jedno query dla wszystkich posi≈Çk√≥w z wszystkich dni
const meals = await supabase
  .from('plan_meals')
  .select('*, recipes(*)')
  .in('plan_day_id', dayIds)  // All days at once
```

#### 2. Pobranie du≈ºych struktur
**WƒÖskie gard≈Ço**: Plan na 1 rok (365 dni) z 3 posi≈Çkami na dzie≈Ñ = 1095 posi≈Çk√≥w
**RozwiƒÖzanie**:
- Dla MVP: Zaakceptuj (typowe plany ~7-30 dni)
- Dla przysz≈Ço≈õci: Implementuj paging w query string: `?from_date=2024-01-15&to_date=2024-01-21`

#### 3. BrakujƒÖce indeksy
**WƒÖskie gard≈Ço**: Bazy danych bez indeks√≥w na FK
**RozwiƒÖzanie**: Zapewnij indeksy w migracjach:
```sql
CREATE INDEX idx_plan_days_plan_id ON plan_days(plan_id);
CREATE INDEX idx_plan_day_slot_targets_plan_day_id ON plan_day_slot_targets(plan_day_id);
CREATE INDEX idx_plan_meals_plan_day_id ON plan_meals(plan_day_id);
```

### Strategia optymalizacji

**Faza 1 (MVP)**:
- Jedno zagnie≈ºd≈ºone query z JOINami zamiast wielu oddzielnych
- Limit na d≈Çugo≈õƒá planu (np. max 365 dni)
- In-memory grouping i transformacja

**Faza 2 (Po MVP)**:
- Dodaj paging: `/api/plans/{id}?from_date=2024-01-15&to_date=2024-01-21`
- Cache popularne plany (Redis) - dla authenticated users cache is safe
- Optimize selected columns - nie pobieraj `created_at`, `updated_at` je≈õli nie potrzebne

**Faza 3 (Skalowanie)**:
- GraphQL fragment-based fetching
- Materialized views dla zagnie≈ºd≈ºonych struktur
- CDN cache na poziomie klienta

### Metryki do monitorowania
- Query time (target < 200ms dla typowego planu)
- Response size (target < 500KB dla 30-dniowego planu)
- Cache hit rate (je≈õli wdro≈ºysz cache)
- 95th percentile latency

---

## 9. Etapy wdro≈ºenia (v2 Updated)

### Etap 1: Przygotowanie infrastruktury

1. **Aktualizacja schemat√≥w walidacji** (`src/lib/schemas/plan.ts`)
    - Dodaj lub zaktualizuj Zod schema: `getPlanIdSchema`
    - Waliduj ID jako dodatniƒÖ liczbƒô ca≈ÇkowitƒÖ
    - Testuj edge cases (0, -1, string, float)

2. **PrzeglƒÖd typ√≥w** (`src/types.ts` ‚Äî zupdate dla v2)
    - Weryfikuj: `PlanDetailsResponse`, `PlanDayResponse`, `MealResponse`
    - **üÜï WA≈ªNE**: Dodaj `portions_to_cook: number | null` do `MealResponse`
    - Upewnij siƒô, ≈ºe nazwy p√≥l pasujƒÖ do bazy danych

3. **PrzeglƒÖd struktury bazy** (`supabase/migrations/`)
    - Weryfikuj: constraints, FK relationships
    - Dodaj indeksy (je≈õli brakujƒÖ):
        - `idx_plan_days_plan_id`
        - `idx_plan_day_slot_targets_plan_day_id`
        - `idx_plan_meals_plan_day_id`
    - **üÜï VERIFY**: plan_meals tabela ma kolumny v2:
        - `portions_to_cook INTEGER NULL`
        - `is_leftover BOOLEAN`

### Etap 2: Implementacja logiki serwisu (v2 Updated)

4. **Rozszerzenie `src/lib/services/plans.service.ts`**
    - Dodaj lub zaktualizuj metodƒô: `getPlanDetailsWithMeals(planId: number, userId: string)`
    - Logika:
      ```
      a) Query: SELECT plan WHERE id = planId AND user_id = userId
      b) Je≈õli nie znaleziono: return null
      c) Query: SELECT plan_days WHERE plan_id = planId ORDER BY date
      d) Query: SELECT plan_day_slot_targets WHERE plan_day_id IN (dayIds)
      e) Query: SELECT plan_meals JOIN recipes WHERE plan_day_id IN (dayIds)
         üÜï IMPORTANT: Include portions_to_cook column
      f) Transformuj do PlanDetailsResponse (v2: map portions_to_cook)
      g) Return plan details
      ```
    - Error handling:
        - Rzuƒá `NotFoundError` je≈õli plan nie istnieje
        - Rzuƒá `AuthorizationError` je≈õli `plan.user_id !== userId`
        - Rzuƒá `DatabaseError` na SQL errors

5. **Dodaj/Zaktualizuj helper do transformacji** (w `plans.service.ts` lub `utils.ts`)
    - Funkcja: `transformToPlanDetailsResponse(rawData)`
    - Mapuj: surowe dane z bazy ‚Üí strukturƒô PlanDetailsResponse
    - **üÜï IMPORTANT**: Mapuj `portions_to_cook` z bazy na DTO
    - Obs≈Çuguj null/undefined warto≈õci dla `portions_to_cook`

6. **Pseudo-kod transformacji v2**:
```typescript
const mealResponseV2 = meals.map(meal => ({
  id: meal.id,
  slot: meal.slot,
  status: meal.status,
  calories_planned: meal.calories_planned,
  portion_multiplier: meal.portion_multiplier,
  portions_to_cook: meal.portions_to_cook,  // üÜï NEW: map directly from DB
  multi_portion_group_id: meal.multi_portion_group_id,
  is_leftover: meal.is_leftover,
  recipe: {
    id: meal.recipes.id,
    name: meal.recipes.name,
    image_url: meal.recipes.image_url,
    time_minutes: meal.recipes.time_minutes,
    source_url: meal.recipes.source_url,
    available_slots: meal.recipes.available_slots
  }
}))
```

### Etap 3: Implementacja endpointu API (v2 Updated)

7. **Utw√≥rz/Zaktualizuj endpoint** (`src/pages/api/plans/[id].ts`)
    - Handler: `export const GET: APIRoute = async ({ params, locals }) => { ... }`
    - Struktura:
      ```typescript
      // 1. Sprawdzenie autoryzacji
      if (!locals.user) return new Response(..., { status: 401 })
 
      // 2. Walidacja parametr√≥w
      const validation = getPlanIdSchema.safeParse({ id: params.id })
      if (!validation.success) return new Response(..., { status: 400 })
 
      // 3. Pobranie danych (v2: includes portions_to_cook)
      try {
        const plan = await plansService.getPlanDetailsWithMeals(
          validation.data.id,
          locals.user.id
        )
      } catch (error) {
        if (error instanceof NotFoundError) return 404
        if (error instanceof AuthorizationError) return 403
        return 500
      }
 
      // 4. Zwrot odpowiedzi
      return new Response(JSON.stringify({ data: plan }), {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
      ```

8. **Dodaj prerender = false**
   ```typescript
   export const prerender = false
   ```

### Etap 4: Testowanie (v2 Updated)

9. **Testy jednostkowe** (`src/lib/services/plans.service.test.ts`)
    - Test: `getPlanDetailsWithMeals` zwraca poprawnƒÖ strukturƒô (z portions_to_cook)
    - Test: `portions_to_cook` jest mapowany z bazy
    - Test: Multi-portion grupy majƒÖ identyczne portion_multiplier
    - Test: Rzuca `NotFoundError` gdy plan nie istnieje
    - Test: Rzuca `AuthorizationError` dla cudzych plan√≥w
    - Test: Transformacja mapuje fields prawid≈Çowo

10. **Testy integracyjne** (curl/QUICK_TEST_REFERENCE.md)
    - Test 401: Brak Authorization headera
    - Test 400: Nieprawid≈Çowy format ID (`abc`, `0`, `-1`)
    - Test 403: Plan nale≈ºy do innego u≈ºytkownika
    - Test 404: ID nie istnieje
    - Test 200: Prawid≈Çowy plan zwraca zagnie≈ºd≈ºone dane (v2)
    - Test: Sprawdzenie struktury odpowiedzi (format JSON, typy p√≥l)
    - **üÜï Test v2**: Sprawdzenie `portions_to_cook` w odpowiedzi
    - **üÜï Test v2**: Sprawdzenie multi-portion grupy (identyczne multipliers, r√≥≈ºne portions_to_cook)

11. **Testy wydajno≈õci** (dla plan√≥w o r√≥≈ºnych rozmiarach)
    - Zmierz czas dla: planu 7-dniowego, 30-dniowego, 100-dniowego
    - Weryfikuj response size
    - Sprawd≈∫ pod kƒÖtem N+1 queries (u≈ºywajƒÖc Supabase Studio)
    - Weryfikuj ≈ºe portions_to_cook jest pobierany (nie NULL dla wszystkich)

### Etap 5: Dokumentacja i wdro≈ºenie

12. **Aktualizacja dokumentacji API**
    - Dodaj do API_TESTING.md lub QUICK_TEST_REFERENCE.md
    - Przyk≈Çad curl:
      ```bash
      curl -X GET https://yourapp.com/api/plans/1 \
        -H "Authorization: Bearer YOUR_TOKEN" \
        -H "Content-Type: application/json"
      ```
    - **üÜï v2**: Wyja≈õnij pola `portions_to_cook`, `is_leftover`, multi-portion grupy

13. **Code review i merge**
    - PR powinien zawieraƒá:
        - Service method z error handling (v2 updated)
        - API endpoint handler
        - Zod schemas
        - Testy (unit + integration)
        - Dokumentacja zmian
        - **üÜï**: Obja≈õnienie v2 semantyki

14. **Wdro≈ºenie**
    - Merge do main
    - Deploy (Vercel/DigitalOcean)
    - Monitoruj logi b≈Çƒôd√≥w w pierwsze 24h
    - Sprawd≈∫ czy portions_to_cook sƒÖ zwracane w odpowiedziach

---

## 10. Checklist do zatwierdzenia (v2 Updated)

- [ ] Zod schema dla walidacji ID napisana i przetestowana
- [ ] Service method `getPlanDetailsWithMeals` implementowana z error handling (v2)
- [ ] **Helper transformacji danych do `PlanDetailsResponse` (v2: map portions_to_cook)**
- [ ] **MealResponse DTO zawiera `portions_to_cook: number | null`**
- [ ] API endpoint handler w `[id].ts` ze wszystkimi c√≥dami b≈Çƒôd√≥w
- [ ] Early returns dla b≈Çƒôd√≥w (guard clauses)
- [ ] **SQL query pobiera `pm.portions_to_cook` z bazy**
- [ ] Testy jednostkowe i integracyjne (w tym v2 semantyki)
- [ ] **Testy sprawdzajƒÖce portions_to_cook w odpowiedzi**
- [ ] **Testy sprawdzajƒÖce multi-portion grupy (identical multipliers)**
- [ ] Dokumentacja curl examples (z v2 wyja≈õnieniami)
- [ ] RLS polityki zweryfikowane w Supabase
- [ ] Indeksy bazy danych (je≈õli brakujƒÖ)
- [ ] Performance baseline zmierzony
- [ ] Code review approval
- [ ] Monitoring/alerting gotowy

---

## 11. v2 Schema Reference

### plan_meals table (v2)
- `id` BIGSERIAL PRIMARY KEY
- `plan_day_id` BIGINT (FK to plan_days)
- `recipe_id` BIGINT (FK to recipes)
- `slot` meal_slot ENUM
- `status` meal_status DEFAULT 'planned'
- `calories_planned` INTEGER
- `portion_multiplier` NUMERIC(8,1) ‚Üê Liczba porcji (not fraction!)
- **`portions_to_cook` INTEGER NULL** ‚Üê NEW in v2
- **`is_leftover` BOOLEAN DEFAULT FALSE** ‚Üê NEW in v2
- `multi_portion_group_id` UUID NULL

### Multi-Portion Example (v2 Data)

**Query**:
```sql
SELECT
    pm.id,
    pm.plan_day_id,
    pd.date,
    pm.slot,
    pm.portion_multiplier,
    pm.portions_to_cook,
    pm.is_leftover,
    pm.multi_portion_group_id,
    r.name as recipe_name,
    r.portions as recipe_portions
FROM plan_meals pm
         JOIN plan_days pd ON pm.plan_day_id = pd.id
         JOIN recipes r ON pm.recipe_id = r.id
WHERE pm.multi_portion_group_id IS NOT NULL
ORDER BY pm.multi_portion_group_id, pd.date;
```

**Expected Result** (multi-portion pair):
```
Day 1 Lunch:
‚îú‚îÄ portion_multiplier: 2.4
‚îú‚îÄ portions_to_cook: 6 ‚Üê Cook the full 6-portion recipe
‚îú‚îÄ is_leftover: FALSE
‚îî‚îÄ multi_portion_group_id: uuid-123

Day 2 Lunch:
‚îú‚îÄ portion_multiplier: 2.4 ‚Üê IDENTICAL!
‚îú‚îÄ portions_to_cook: NULL ‚Üê Don't cook, use leftovers
‚îú‚îÄ is_leftover: TRUE
‚îî‚îÄ multi_portion_group_id: uuid-123 ‚Üê SAME group
```

---

## 12. Appendix: Field Explanations (v2)

### portion_multiplier (v2 Semantics)

```
DEFINITION: How many portions of the recipe to eat

EXAMPLE:
- Recipe: Gulasz (6 portions, 250 kcal per portion)
- Target calories: 600 kcal
- portion_multiplier = 600 / 250 = 2.4

INTERPRETATION: "Eat 2.4 portions of this 6-portion recipe"
- Total calories: 250 √ó 2.4 = 600 kcal ‚úì

MULTI-PORTION PAIR:
- Day 1 (cooking): portion_multiplier = 2.4 (same)
- Day 2 (leftovers): portion_multiplier = 2.4 (IDENTICAL!)
- This ensures you eat the same amount both days
```

### portions_to_cook (v2 NEW)

```
DEFINITION: How many portions to prepare (cook today)

VALUES:
- If is_leftover = FALSE (cooking day): portions_to_cook = recipe.portions
  ‚Üí "Cook the entire recipe today"

- If is_leftover = TRUE (leftovers day): portions_to_cook = NULL
  ‚Üí "Don't cook, use leftovers from yesterday"

EXAMPLE:
- Day 1 (dinner): portions_to_cook = 6 ‚Üí "Cook the 6-portion gulasz"
- Day 2 (lunch): portions_to_cook = NULL ‚Üí "Use yesterday's leftover gulasz"

UI INTERPRETATION:
- portions_to_cook NOT NULL ‚Üí Show "Cook {portions_to_cook} portions"
- portions_to_cook IS NULL AND is_leftover = TRUE ‚Üí Show "Leftovers from yesterday"
- portions_to_cook NOT NULL AND is_leftover = FALSE ‚Üí Show "Cook and eat today"
```

### is_leftover (v2)

```
DEFINITION: Is this a leftover day?

VALUES:
- FALSE: First day of cooking (normal meal)
- TRUE: Second day (using leftovers from yesterday)

MULTI-PORTION PAIR:
- Day 1: is_leftover = FALSE (cooking day)
- Day 2: is_leftover = TRUE (leftovers day)

SINGLE-PORTION MEAL:
- is_leftover = FALSE (always)
```

### multi_portion_group_id (v2)

```
DEFINITION: Groups paired multi-portion meals

STRUCTURE:
- Day 1 meal: multi_portion_group_id = "uuid-abc"
- Day 2 meal: multi_portion_group_id = "uuid-abc" (SAME UUID)

SINGLE-PORTION:
- multi_portion_group_id = NULL
```

---

## 13. Validation & Quality Checklist (v2)

### Pre-Deployment Validation

- [ ] **Type Safety**: All TypeScript strict mode rules satisfied
- [ ] **Validation**: All inputs validated with Zod
- [ ] **Error Handling**: All error paths return appropriate HTTP status
- [ ] **Authentication**: Session verification implemented
- [ ] **Authorization**: User can only view own plans
- [ ] **RLS**: Database policies restrict cross-user access
- [ ] **Documentation**: Code comments explain complex logic
- [ ] **Testing**: Integration tests cover happy path and error cases
- [ ] **Performance**: Response time < 200ms for typical plan
- [ ] **Logging**: Errors logged with context for debugging
- [ ] **Security**: No SQL injection, XSS, or auth bypass vulnerabilities
- [ ] **v2 Semantics**: `portions_to_cook` is returned in response
- [ ] **Multi-Portion**: Groups shown with identical multipliers and different portions_to_cook
- [ ] **Data Integrity**: Constraints enforced (DB level via triggers)

### Code Quality Standards

- **Coverage**: > 80% test coverage for service layer
- **Linting**: Pass ESLint with zero warnings
- **Type Errors**: Zero TypeScript errors
- **Documentation**: JSDoc comments for all public functions
- **Error Messages**: User-friendly, actionable error messages

---

**Plan v ready for implementation!** ‚úÖ
